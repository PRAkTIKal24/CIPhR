import base64
import glob
import logging
import os
import re
from datetime import datetime
from pathlib import Path
from typing import Optional

import pypandoc
import requests

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)


class WordPressPublisher:
    """Handles publishing markdown content to WordPress via REST API."""

    def __init__(self, site_url: str, username: str, app_password: str):
        """
        Initialize WordPress publisher.

        Args:
            site_url: WordPress site URL (e.g., 'https://www.idmeu.org')
            username: WordPress username
            app_password: WordPress application password
        """
        self.site_url = site_url.rstrip("/")
        self.username = username
        self.app_password = app_password
        self.api_base = f"{self.site_url}/wp-json/wp/v2"

        # Create authorization header
        credentials = f"{username}:{app_password}"
        token = base64.b64encode(credentials.encode()).decode()
        self.headers = {
            "Authorization": f"Basic {token}",
            "Content-Type": "application/json",
        }

    def convert_markdown_to_html(self, markdown_content: str) -> str:
        """
        Convert markdown table to HTML for WordPress using pandoc.
        Falls back to custom parser if pandoc fails.

        Args:
            markdown_content: The markdown content to convert

        Returns:
            str: HTML formatted content
        """
        if not markdown_content.strip():
            return "<p>No research data available.</p>"

        try:
            # Try using pandoc for robust conversion

            # Convert markdown to HTML using pandoc
            html_body = pypandoc.convert_text(
                markdown_content,
                "html",
                format="md",
                # Note: --table-classes not available in all pandoc versions
            )

            # Post-process to add WordPress table classes
            html_body = html_body.replace(
                "<table>", '<table class="wp-block-table is-style-stripes">'
            )

            # Wrap in our custom div and add styling
            html = '<div class="ciphr-research-table">\n'
            html += html_body
            html += "\n</div>\n"

            # Add timestamp and source info
            current_time = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
            html += f'\n<p><em>Last updated: {current_time} | Generated by <a href="https://github.com/PRAkTIKal24/CIPhR" target="_blank">CIPhR</a></em></p>\n'

            logging.info("Successfully converted markdown to HTML using pandoc")
            return html

        except Exception as e:
            logging.warning(
                f"Pandoc conversion failed: {e}, falling back to custom parser"
            )
            return self._convert_markdown_to_html_fallback(markdown_content)

    def _convert_markdown_to_html_fallback(self, markdown_content: str) -> str:
        """
        Fallback markdown to HTML converter (custom implementation).

        Args:
            markdown_content: The markdown content to convert

        Returns:
            str: HTML formatted content
        """

        lines = [
            line.strip()
            for line in markdown_content.strip().split("\n")
            if line.strip()
        ]
        if not lines:
            return "<p>No research data available.</p>"

        # Find header and data rows
        header_line = None
        data_lines = []
        separator_found = False

        for i, line in enumerate(lines):
            # Check if line contains table separators (could be header separator)
            if re.match(r"^\s*\|?[\s\-\|:]+\|?\s*$", line):
                separator_found = True
                if i > 0:  # Previous line should be header
                    header_line = lines[i - 1]
                continue

            # If we found separator, everything after is data
            if separator_found and "|" in line:
                data_lines.append(line)
            # If no separator yet but line has pipes, could be header or data
            elif "|" in line:
                if header_line is None:
                    header_line = line
                else:
                    # Multiple pipe lines without separator - treat as data
                    data_lines.append(line)

        # If no clear separator, try to infer header/data
        if not separator_found and len(lines) >= 2:
            # First line with pipes is likely header
            for line in lines:
                if "|" in line:
                    if header_line is None:
                        header_line = line
                    else:
                        data_lines.append(line)

        # Validate we have at least a header
        if not header_line:
            return "<p>No valid table structure found.</p>"

        # Parse header
        headers = self._parse_table_row(header_line)
        if not headers:
            return "<p>No valid table headers found.</p>"

        # Start HTML table
        html = '<div class="ciphr-research-table">\n'
        html += '<table class="wp-block-table is-style-stripes">\n'
        html += "<thead>\n<tr>\n"

        for header in headers:
            html += f"<th>{self._escape_html(header)}</th>\n"

        html += "</tr>\n</thead>\n<tbody>\n"

        # Add data rows
        for line in data_lines:
            cells = self._parse_table_row(line)
            if cells:
                html += "<tr>\n"
                # Pad cells to match header count
                while len(cells) < len(headers):
                    cells.append("")

                for _i, cell in enumerate(
                    cells[: len(headers)]
                ):  # Don't exceed header count
                    processed_cell = self._process_cell_content(cell)
                    html += f"<td>{processed_cell}</td>\n"
                html += "</tr>\n"

        html += "</tbody>\n</table>\n</div>\n"

        # Add timestamp and source info
        current_time = datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC")
        html += f'\n<p><em>Last updated: {current_time} | Generated by <a href="https://github.com/PRAkTIKal24/CIPhR" target="_blank">CIPhR</a></em></p>\n'

        return html

    def _parse_table_row(self, line: str) -> list:
        """
        Parse a table row, handling various formats.

        Args:
            line: Table row string

        Returns:
            list: List of cell contents
        """
        # Remove leading/trailing pipes and split
        line = line.strip()
        if line.startswith("|"):
            line = line[1:]
        if line.endswith("|"):
            line = line[:-1]

        # Split by pipe and clean up
        cells = [cell.strip() for cell in line.split("|")]
        return [
            cell for cell in cells if cell or len(cells) <= 1
        ]  # Keep empty cells only if single cell

    def _process_cell_content(self, cell: str) -> str:
        """
        Process cell content, converting markdown links and escaping HTML.

        Args:
            cell: Cell content

        Returns:
            str: Processed HTML content
        """

        # Convert markdown links to HTML
        # Handle [text](url) format
        link_pattern = r"\[([^\]]+)\]\(([^)]+)\)"

        def replace_link(match):
            text = match.group(1)
            url = match.group(2)
            return f'<a href="{url}" target="_blank">{self._escape_html(text)}</a>'

        cell = re.sub(link_pattern, replace_link, cell)

        # Handle plain URLs (basic detection)
        url_pattern = r"(https?://[^\s]+)"

        def replace_url(match):
            url = match.group(1)
            return f'<a href="{url}" target="_blank">{url}</a>'

        # Only replace URLs that aren't already in HTML tags
        if "<a href=" not in cell:
            cell = re.sub(url_pattern, replace_url, cell)

        # Escape remaining HTML characters
        cell = self._escape_html_partial(cell)

        return cell

    def _escape_html(self, text: str) -> str:
        """Escape HTML characters."""
        return (
            text.replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace('"', "&quot;")
            .replace("'", "&#x27;")
        )

    def _escape_html_partial(self, text: str) -> str:
        """Escape HTML characters but preserve existing HTML tags."""
        # Simple approach: only escape < and > that aren't part of tags

        # Protect existing HTML tags
        protected = []

        def protect_tag(match):
            protected.append(match.group(0))
            return f"__PROTECTED_{len(protected) - 1}__"

        text = re.sub(r"<[^>]+>", protect_tag, text)

        # Escape remaining characters
        text = text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

        # Restore protected tags
        for i, tag in enumerate(protected):
            text = text.replace(f"__PROTECTED_{i}__", tag)

        return text

    def find_ciphr_post(self) -> Optional[int]:
        """
        Find existing CIPhR post by title.

        Returns:
            int: Post ID if found, None otherwise
        """
        try:
            # Search for posts with CIPhR in title
            search_url = f"{self.api_base}/posts"
            params = {"search": "CIPhR Research Insights", "per_page": 10}

            response = requests.get(
                search_url, headers=self.headers, params=params, timeout=30
            )

            if response.status_code == 200:
                posts = response.json()
                for post in posts:
                    if "CIPhR" in post.get("title", {}).get("rendered", ""):
                        logging.info(f"Found existing CIPhR post: ID {post['id']}")
                        return post["id"]
            else:
                logging.warning(f"Search request failed: {response.status_code}")

        except Exception as e:
            logging.warning(f"Error searching for existing post: {e}")

        return None

    def create_or_update_post(
        self, markdown_content: str, paper_count: int = 0
    ) -> bool:
        """
        Create new post or update existing CIPhR post.

        Args:
            markdown_content: Markdown content to publish
            paper_count: Number of papers in the update

        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Convert markdown to HTML
            html_content = self.convert_markdown_to_html(markdown_content)

            # Prepare post data
            current_date = datetime.utcnow().strftime("%Y-%m-%d")
            title = f"CIPhR Research Insights - {current_date}"

            # Create post description based on content
            if paper_count > 0:
                description = f"Latest physics research insights from arXiv. This automated daily update includes {paper_count} new papers analyzed by CIPhR."
            else:
                description = "Latest physics research insights from arXiv, automatically updated daily by CIPhR."

            post_data = {
                "title": title,
                "content": html_content,
                "excerpt": description,
                "status": "publish",
                "categories": [1],  # Default category, adjust as needed
                "tags": ["physics", "research", "arxiv", "automation", "dark-matter"],
            }

            # Try to find existing post
            existing_post_id = self.find_ciphr_post()

            if existing_post_id:
                # Update existing post
                update_url = f"{self.api_base}/posts/{existing_post_id}"
                response = requests.post(
                    update_url, headers=self.headers, json=post_data, timeout=60
                )

                if response.status_code == 200:
                    post_data = response.json()
                    post_url = post_data.get("link", "Unknown")
                    logging.info(f"Successfully updated WordPress post: {post_url}")
                    return True
                else:
                    logging.error(
                        f"Failed to update WordPress post: {response.status_code} - {response.text}"
                    )
                    return False
            else:
                # Create new post
                create_url = f"{self.api_base}/posts"
                response = requests.post(
                    create_url, headers=self.headers, json=post_data, timeout=60
                )

                if response.status_code == 201:
                    post_data = response.json()
                    post_url = post_data.get("link", "Unknown")
                    logging.info(f"Successfully created WordPress post: {post_url}")
                    return True
                else:
                    logging.error(
                        f"Failed to create WordPress post: {response.status_code} - {response.text}"
                    )
                    return False

        except Exception as e:
            logging.error(f"Error publishing to WordPress: {e}")
            return False

    def test_connection(self) -> bool:
        """
        Test WordPress API connection.

        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            test_url = f"{self.api_base}/posts"
            params = {"per_page": 1}

            response = requests.get(
                test_url, headers=self.headers, params=params, timeout=30
            )

            if response.status_code == 200:
                logging.info("WordPress API connection successful")
                return True
            else:
                logging.error(
                    f"WordPress API connection failed: {response.status_code}"
                )
                return False

        except Exception as e:
            logging.error(f"WordPress API connection error: {e}")
            return False


def publish_research_insights(
    markdown_file_path: str,
    site_url: str,
    username: str,
    app_password: str,
    paper_count: int = 0,
) -> bool:
    """
    Publish research insights from markdown file to WordPress.
    Automatically finds the correct output file if LLM questions changed.

    Args:
        markdown_file_path: Path to the markdown file (can be base name)
        site_url: WordPress site URL
        username: WordPress username
        app_password: WordPress application password
        paper_count: Number of papers processed (for description)

    Returns:
        bool: True if successful, False otherwise
    """
    try:
        # Find the actual output file (handles question changes)
        actual_file_path = find_latest_output_file(markdown_file_path)

        # Read markdown content
        if not os.path.exists(actual_file_path):
            logging.error(f"Markdown file not found: {actual_file_path}")
            return False

        with open(actual_file_path, "r", encoding="utf-8") as f:
            markdown_content = f.read()

        if not markdown_content.strip():
            logging.error("Markdown file is empty")
            return False

        # Initialize WordPress publisher
        publisher = WordPressPublisher(site_url, username, app_password)

        # Test connection first
        if not publisher.test_connection():
            logging.error("WordPress connection test failed")
            return False

        # Publish content
        success = publisher.create_or_update_post(markdown_content, paper_count)

        if success:
            logging.info(
                f"Successfully published research insights from {actual_file_path} to WordPress"
            )
        else:
            logging.error("Failed to publish research insights to WordPress")

        return success

    except Exception as e:
        logging.error(f"Error in publish_research_insights: {e}")
        return False


def find_latest_output_file(base_file_path: str) -> str:
    """
    Find the latest output file, handling cases where LLM questions changed.

    Args:
        base_file_path: Base file path (e.g., 'output/hepex.md')

    Returns:
        str: Path to the actual output file to use
    """

    # If the base file exists, use it
    if os.path.exists(base_file_path):
        logging.info(f"Using base output file: {base_file_path}")
        return base_file_path

    # Look for files with date suffixes
    base_path = Path(base_file_path)
    directory = base_path.parent
    name_stem = base_path.stem
    extension = base_path.suffix

    # Pattern: hepex_DDMMYY.md
    pattern = str(directory / f"{name_stem}_*{extension}")
    matching_files = glob.glob(pattern)

    if matching_files:
        # Sort by modification time (most recent first)
        latest_file = max(matching_files, key=os.path.getmtime)
        logging.info(
            f"LLM questions appear to have changed. Using latest output file: {latest_file}"
        )
        return latest_file

    # Fallback to original path (will cause error but gives clear message)
    logging.warning(f"No output files found. Falling back to: {base_file_path}")
    return base_file_path


if __name__ == "__main__":
    # Test the WordPress publisher
    test_markdown = """Paper Title | arXiv Link | What is the main physics phenomenon studied by this paper
----------- | ---------- | ---------------------------------------------------------
Test Paper | [Link](http://arxiv.org/abs/test123) | Testing WordPress integration
"""

    # These would come from environment variables in actual use
    site_url = os.getenv("WP_SITE_URL", "https://www.idmeu.org")
    username = os.getenv("WP_USERNAME", "test_user")
    app_password = os.getenv("WP_APP_PASSWORD", "test_password")

    publisher = WordPressPublisher(site_url, username, app_password)

    # Test connection
    if publisher.test_connection():
        print("✅ WordPress connection successful")
        # Test HTML conversion
        html = publisher.convert_markdown_to_html(test_markdown)
        print("Generated HTML:")
        print(html)
    else:
        print("❌ WordPress connection failed")
